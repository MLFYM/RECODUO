#  :wrench:웹 서비스 개발

> 이 문서에서는 데이터 전처리 과정부터 병행해왔던 구체적인 웹 서비스 구현 과정에 대하여 다룬다. 기본적인 화면 구성부터 구체적인 기능 구현에 대해 설명을 포함한다. 



## 0. 준비 과정

![KakaoTalk_20200619_124911264](https://user-images.githubusercontent.com/58945760/85095315-f7dcc500-b22b-11ea-9b78-946b8fc8dd29.png)

backend는 `django`를 통해 웹 서비스를 구현하였고,  코딩에 사용한 주요 `tool`은 `Atom`입니다. 



## 1. 기본 화면 구성

- [화면계획서]()
- 웹 시나리오 

![웹 흐름도](https://user-images.githubusercontent.com/58945760/89790495-f7dab080-db5c-11ea-85c4-dd8bb362853c.PNG)



## 2. 웹캠 접근 및 구현

> 노트북의 웹캠에 접근하여 사용자의 얼굴을 받아들이도록 한다. 



## 3. 이미지 전송

> 웹캠으로 받아들인 이미지를 다음 페이지로 저장, 전송한다. 



## 4. 감정분류 모델 적용

> 미리 만들어둔 모델을 프로젝트 내에서 적용하여 결과를 출력한다. 

먼저 가중치를 미리 저장해둔 `h5` 파일이 필요하다. 또한 해당 파일을 불러와 데이터에 적용하는 용도의 `face_function.py` 파일을 생성한다. 이 두 개의 파일이 준비되었다면 준비는 거의 끝난 셈이다.

 남은 일은 `views.py`에서 함수 형식의 `face_function`을 import하고, 모델 결과에 따라 메시지를 출력하도록 만들면 된다. 



## 5. Youtube playlist 재생

> 모델의 감정 분류 결과에 따라 playlist가 재생되도록 한다.

먼저, 각 감정분류별로 재생되는  `default playlist`가 존재한다. 이 playlist들이 존재하는 이유는 추천 알고리즘에 **최소한의 기준**을 부여하기 위한 것이다. 멜론 dataset의 태그는 **playlist 기준**으로,  한 playlist당 태그가 부여되어 있으며 한 태그가 아닌 다수의 태그가 붙어있는 경우도 많았다. 또한 같은 playlist의 태그라도 각자 성격이 다른 태그가 존재하기도 하였다. 

회의 끝에 전체 dataset의 태그 라벨링보다는 기준이 될 playlist를 생성하여 곡별 태그를 부여하는 것이 보다 효율적이라는 판단을 내렸고, 팀원 전원이 youtube의 인기 playlist와 음악 스트리밍 사이트의 playlist를 참고하여 수작업으로 구성하였다. 곡별 태그는 멜론 dataset의 전체 태그 목록에 포함된 태그 중 골라 라벨링하였다.

  

## 6.1. 음악 추천 기능 구현

> 미리 만들어둔 음악 추천 알고리즘을 적용한다. 

![필터링](https://user-images.githubusercontent.com/58945760/89897022-5d8c7280-dc19-11ea-8c75-779970ee6cd6.PNG)

### 6.1.1. 음악 추천 알고리즘 

> 해당 서비스에 적용된 추천 알고리즘은 협업 필터링과 콘텐츠 기반 필터링이 혼합된 형태이며, 자세한 설명은 [링크](https://github.com/MLFYM/RECODUO/blob/master/technical_blog/04_%EC%B6%94%EC%B2%9C%EC%8B%9C%EC%8A%A4%ED%85%9C/Recommender_System_For_Music.md#recommender-system-for-music)에 자세히 설명되어 있다. 추천 시스템에 대한 기본적인 내용은 [이 링크](https://github.com/MLFYM/RECODUO/blob/master/technical_blog/04_%EC%B6%94%EC%B2%9C%EC%8B%9C%EC%8A%A4%ED%85%9C/RecommendationSystem.md#recommender-system)를 참조한다. 

음악 알고리즘의 메커니즘은 이하의 스크린샷과 같다. 

![추천 알고리즘 메커니즘](https://user-images.githubusercontent.com/58945760/91578906-cb5ccc00-e985-11ea-82b3-b714cae5000e.PNG)

`input`으로 들어가는 값은 재생 중인 음악이 melon dataset에서 가지는 고유 코드와 그 곡에 붙은 태그이다. melon dataset에서 태그는 playlist를 기준으로 매겨져 있기에 default playlist에는 **곡이 포함된 playlist의 태그를 고려하여 곡별 태그를 선정**하였다. 알고리즘을 거치면 `output`으로써 추천곡의 제목과 아티스트명이 `string`으로 반환된다.  

이 값들은 아래의 Google 크롤링 코드의 `input` 값이 된다. 

### 6.1.2 추천 음악 링크 추출

> 웹페이지에서 재생되는 Youtube 영상 링크는 Google 웹 크롤링을 통해 추출한다.  

크롤링할 사이트로 Google을 선택한 이유는 노래 제목+아티스트명으로 검색하였을 때 공식 영상에 가까운 동영상을 최상단에 보여주기에, 보다 높은 품질의 영상을 사용자에게 제공할 수 있기 때문이다.  

한 곡을 크롤링하는 데 생기는 문제점과 그 해결 방법



## 6.2. 선택지 기능 구현

> 재생된 default playlist의 음악이 사용자의 마음에 들지 않을 경우, 보다 사용자의 취향에 맞춘 음악을 들려주기 위해 질문 & 답변 set를 제공한다. 해당 답변에 따라 맞춤 playlist를 추천해 준다.

 감정별로 세 가지 질문 & 4~5지선다형 답변 세트가 있으며, 해당 질문과 답변들은 사용자가 쉽게 질리지 않도록 친구나 지인과의 대화에서 으레 나올 법한 친근하고 일상적인 질문들을 간추려 뽑았다. 답변 선택 시 재생되는 playlist는 관련 youtube playlist들과 keyword 검색 등을 통해 default playlist와 마찬가지로 수작업으로 구성하였다.  



## 7. 음악 재추천 loop 구현

> 추천받은 음악이 마음에 들어 또 다른 음악을 추천받고 싶을 때, 계속적으로 추천을 받을 수 있도록 한다. 

기본적으로 위의 음악 추천 알고리즘과 동일하나, 알고리즘을 적용하기 전 `input`으로 들어갈 곡 태그를 선택하는 과정이 들어간다. 위에서 말했듯이 melon dataset에서 곡의 태그는 playlist를 기준으로 매겨져 있고, 태그는 하나가 아니라 다수일 때도 많았다. 이를 활용한 곡 태그 선정 방법은 다음과 같다. 

먼저 현재 곡이 포함된 모든 플레이리스트를 불러오고, 그 플레이리스트에 붙은 태그들을 리스트로 만들어 중복되는 값을 카운트한다. 그 중에서 가장 중복이 많은 값을 곡 태그로 선정한다. 만약 중복되는 태그가 존재하지 않을 경우, 리스트 내에 존재하는 태그들 중 랜덤으로 곡 태그를 선정하도록 한다. 

그 다음 과정은 6.1.1의 내용과 같다. 

